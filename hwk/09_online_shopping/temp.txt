class BPlusTree {
private:
    // B+ tree node structure
    struct Node {
        bool isLeaf;
        std::vector<double> keys;  // Price keys
        std::vector<Product> products;  // Leaf nodes contain products
        std::vector<Node*> children;  // Internal nodes contain children pointers
        Node* next;  // Pointer to next leaf node for range queries
        
        Node(bool leaf) : isLeaf(leaf), next(nullptr) {}
    };
    
    Node* root;
    int order;  // Maximum number of children per node
    
public:
    BPlusTree(int order = 4) : order(order) {
        root = new Node(true);  // Start with a leaf node
    }
    
    // Insert a product into the B+ tree indexed by price
    void insert(const Product& product) {
        // Implementation details...
    }
    
    // Find all products within price range [min, max]
    std::vector<Product> rangeSearch(double min, double max) {
        std::vector<Product> result;
        
        // Find leaf node containing min price
        Node* current = findLeafNode(root, min);
        
        // Traverse leaf nodes collecting products within range
        while (current != nullptr) {
            for (size_t i = 0; i < current->keys.size(); i++) {
                if (current->keys[i] >= min && current->keys[i] <= max) {
                    result.push_back(current->products[i]);
                }
                
                if (current->keys[i] > max) {
                    break;  // Reached end of range
                }
            }
            
            // If largest key in current node is <= max, move to next leaf
            if (!current->keys.empty() && current->keys.back() <= max) {
                current = current->next;
            } else {
                break;
            }
        }
        
        // Sort results by criteria
        std::sort(result.begin(), result.end());
        
        return result;
    }
    
private:
    Node* findLeafNode(Node* node, double price) {
        // Find leaf node that would contain the price
        // Implementation details...
    }
};